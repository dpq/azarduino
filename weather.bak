/* 
 Uses code from  Weather Shield Example by Nathan Seidle from SparkFun Electronics [November 16th, 2013]
 Original license: This code is public domain but you buy me a beer if you use this and we meet someday (Beerware license).
 Much of this is based on Mike Grusin's USB Weather Board code: https://www.sparkfun.com/products/10586
 Modified for the Azazel project by David Parunakian [May/June 2014], I prefer Red Bull to beer in case anyone cares (Bullware license).
*/

#include <Wire.h> //I2C needed for sensors

#include "MPL3115A2.h" //Pressure sensor
MPL3115A2 p;

#include "HTU21D.h" //Humidity sensor
HTU21D h;

#include <SoftwareSerial.h> //Needed for GPS
#include "TinyGPS++.h" //GPS parsing
TinyGPSPlus gps;

#include <Adafruit_SI1145.h>
Adafruit_SI1145 uv = Adafruit_SI1145();

#include <Adafruit_ADS1015.h>
Adafruit_ADS1115 ads;

const int pin_MQ131 = 0;
const int pin_MQ9 = 1;
const int pin_FC_22_I = 2;

static const int RXPin = 5, TXPin = 4; // GPS is attached to pin 4(TX from GPS) and pin 5(RX into GPS)
SoftwareSerial ss(RXPin, TXPin); 

//Hardware pin definitions
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// digital I/O pins
const byte WSPEED = 3;
const byte RAIN = 2;
const byte GPS_PWRCTL = 6; //Pulling this pin low puts GPS to sleep but maintains RTC and RAM

// analog I/O pins
const byte REFERENCE_3V3 = A3;
const byte LIGHT = A1;
const byte BATT = A2;
const byte WDIR = A0;

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

//Global Variables
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
long lastSecond;
long lastWindCheck = 0, lastRainCheck = 0;

// volatiles are subject to modification by IRQs
volatile unsigned long lastRainIRQ = 0, lastWindIRQ = 0;
volatile byte windClicks = 0, rainClicks = 0;

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

//Interrupt routines (these are called by the hardware interrupts, not by the main code)
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
/* The rain gauge is a self-emptying tipping bucket type. Each 0.011‚Äù (0.2794 mm) of rain causes
one momentary contact closure that can be recorded with a digital counter or microcontroller interrupt input */
void rainIRQ() {
  // Combat overflow
  if (millis() < lastRainIRQ) {
    lastRainIRQ = 0;
    return;
  }

  // ignore switch-bounce glitches less than 10ms after initial edge
  if (millis() - lastRainIRQ > 10) {
    lastRainIRQ = millis();
    rainClicks++;
  }
}

/* The cup-type anemometer measures wind speed by closing a contact as a magnet moves past a switch.
A wind speed of 1.492 MPH (2.4km/h) causes the switch to close once per second. */
void wspeedIRQ() {
  // Combat overflow
  if (millis() < lastWindIRQ) {
    lastWindIRQ = 0;
    return;
  }

  // Ignore switch-bounce glitches less than 10ms (142MPH max reading) after the switch closes
  if (millis() - lastWindIRQ > 10) {
    lastWindIRQ = millis(); //Grab the current time
    windClicks++;
  }
}

//Returns the instantaneous wind speed
float windSpeed() {
  float _windSpeed = 1.492*(float)windClicks*1000.0 / (millis() - lastWindCheck);
  windClicks = 0; lastWindCheck = millis();
  return _windSpeed;
}

float rainRate() {
  float _rainRate = 0.11*(float)rainClicks*1000.0 / (millis() - lastRainCheck);
  rainClicks = 0; lastRainCheck = millis();
  return _rainRate;
}


//Read the wind direction sensor, return heading in degrees
int windDirection()  {
  unsigned int adc = analogRead(WDIR); // get the current reading from the sensor

  // The following table is ADC readings for the wind direction sensor output, sorted from low to high.
  // Each threshold is the midpoint between adjacent headings. The output is degrees for that ADC reading.
  // Note that these are not in compass degree order! See Weather Meters datasheet for more information.

  if (adc < 380) return (113);
  if (adc < 393) return (68);
  if (adc < 414) return (90);
  if (adc < 456) return (158);
  if (adc < 508) return (135);
  if (adc < 551) return (203);
  if (adc < 615) return (180);
  if (adc < 680) return (23);
  if (adc < 746) return (45);
  if (adc < 801) return (248);
  if (adc < 833) return (225);
  if (adc < 878) return (338);
  if (adc < 913) return (0);
  if (adc < 940) return (293);
  if (adc < 967) return (315);
  if (adc < 990) return (270);
  return (-1); // error, disconnected?
}

//While we delay for a given amount of time, gather GPS data
static void smartDelay(unsigned long ms) {
}

//Returns the voltage of the light sensor based on the 3.3V rail
//This allows us to ignore what VCC might be (an Arduino plugged into USB has VCC of 4.5 to 5.2V)
float lightLevel() {
  float operatingVoltage = analogRead(REFERENCE_3V3);
  float lightSensor = analogRead(LIGHT);
  operatingVoltage = 3.3 / operatingVoltage; //The reference voltage is 3.3V
  lightSensor = operatingVoltage * lightSensor;
  return(lightSensor);
}

//Returns the voltage of the raw pin based on the 3.3V rail
//This allows us to ignore what VCC might be (an Arduino plugged into USB has VCC of 4.5 to 5.2V)
//Battery level is connected to the RAW pin on Arduino and is fed through two 5% resistors:
//3.9K on the high side (R1), and 1K on the low side (R2)
float batteryLevel() {
  float operatingVoltage = analogRead(REFERENCE_3V3);
  float rawVoltage = analogRead(BATT);
  operatingVoltage = 3.30 / operatingVoltage; //The reference voltage is 3.3V
  rawVoltage = operatingVoltage * rawVoltage; //Convert the 0 to 1023 int to actual voltage on BATT pin
  rawVoltage *= 4.90; //(3.9k+1k)/1k - multiple BATT voltage by the voltage divider to get actual system voltage
  return(rawVoltage);
}


void printWeather() {
  Serial.print("Wind direction [deg] ADS80422:");
  Serial.print(windDirection());

  Serial.print(";Wind speed [mph] ADS80422:");
  Serial.print(windSpeed(), 1);

  Serial.print(";Precipitation [in/sec] ADS80422:");
  Serial.print(rainRate(), 2);

  Serial.print(";Humidity [%] HTU21D(F):");
  Serial.print(h.readHumidity(), 1);

  Serial.print(";Temperature [C*] MPL3115A2:");
  Serial.print(p.readTemp(), 1);

  Serial.print(";Pressure [Pa] MPL3115A2:");
  Serial.print(p.readPressure(), 2);

  Serial.print(";Ambient light ALS-PT19-315C/L177/TR8:");
  Serial.print(lightLevel(), 2);

  Serial.print(";UV index SI1145:");
  Serial.print(uv.readUV());

  Serial.print(";Noxious gas [ppm] FC-22-I:");
  Serial.print(ads.readADC_SingleEnded(pin_FC_22_I));

  Serial.print(";O3 & Cl2 [ppm] MQ131:");
  Serial.print(ads.readADC_SingleEnded(pin_MQ131));

  Serial.print(";Combustible gas [ppm] MQ9:");
  Serial.print(ads.readADC_SingleEnded(pin_MQ9));

  Serial.print(";Lat [deg] GP635T:");
  Serial.print(gps.location.lat(), 6);
  Serial.print(";Lon [deg] GP635T:");
  Serial.print(gps.location.lng(), 6);
  Serial.print(";Alt [m] GP635T:");
  Serial.print(gps.altitude.meters());

  Serial.print(";Battery voltage [V]:");
  Serial.print(batteryLevel(), 2);

  Serial.println();
}

void setup() {
  Serial.begin(9600);

  ss.begin(9600); //Begin listening to GPS over software serial at 9600. This should be the default baud of the module.
  
  pinMode(GPS_PWRCTL, OUTPUT);
  digitalWrite(GPS_PWRCTL, HIGH); //Pulling this pin low puts GPS to sleep but maintains RTC and RAM
  
  pinMode(WSPEED, INPUT_PULLUP); // input from wind meters windspeed sensor
  pinMode(RAIN, INPUT_PULLUP); // input from wind meters rain gauge sensor
  
  pinMode(REFERENCE_3V3, INPUT);
  pinMode(LIGHT, INPUT);

  //Configure the pressure sensor
  p.begin(); // Get sensor online
  p.setModeBarometer(); // Measure pressure in Pascals from 20 to 110 kPa
  p.setOversampleRate(7); // Set Oversample to the recommended 128
  p.enableEventFlags(); // Enable all three pressure and temp event flags 
	
  //Configure the humidity sensor
  h.begin();
  ads.begin();

  lastSecond = millis();

  // attach external interrupt pins to IRQ functions
  attachInterrupt(0, rainIRQ, FALLING);
  attachInterrupt(1, wspeedIRQ, FALLING);

  uv.begin();

  // turn on interrupts
  interrupts();

  Serial.println("INIT");
}

void loop() {
  //Keep track of which minute it is
  if (millis() < lastSecond) {
    lastSecond = 0;
  }
  else if (millis() - lastSecond >= 1000) {
    lastSecond += 1000;
    printWeather();
  }

  unsigned long start = millis();
  do {
    while (ss.available()) {
      gps.encode(ss.read());
    }
  } while (millis() - start < 8000);
}
